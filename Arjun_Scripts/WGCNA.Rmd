---
title: "WGCNA Analysis"
author: "Arjun Baghela"
date: "March 12, 2017"
output: html_document
---
# source("http://bioconductor.org/biocLite.R") 
# biocLite(c("AnnotationDbi", "impute", "GO.db", "preprocessCore"))
# install.packages(WGCNA)

```{r, message=FALSE, warning=FALSE}
library(tidyverse)
library(magrittr)
library(edgeR)
library(DESeq2)
library(WGCNA)
options(stringsAsFactors = FALSE)

```

```{r}
getwd()
countdata <- read.table(file= "Raw_Data/GSE85567_RNASeq_normalizedcounts.txt", check.names = FALSE)
metadata <- read.csv(file= "Raw_Data/GSE85566_metadata.txt", row.names = 1)

metadata %<>% filter(ID %in% colnames(countdata))
metadata %>% group_by(Status) %>% tally()

colnames(countdata) == metadata$ID
countdata <- countdata[,metadata$ID]
colnames(countdata) == metadata$ID

meta <- meta %>% mutate(OverallLabel = paste0(meta$Treatment,"_",meta$Hour))

colnames(countdata) <- paste0(colnames(countdata), "_", metadata$Status)

```

Filters 
```{r}
noint <- rownames(countdata) %in% c("__no_feature","__ambiguous","__too_low_aQual", "__not_aligned","__alignment_not_unique")

cpms <- cpm(countdata)
keep <- rowSums(cpms >10) >= 25 & !noint
countdata <- countdata[keep,]

dim(countdata)
```


This is for clustering the samples. In case we need to remove outlier samples. 
```{r}
tcount <- as.data.frame(t(countdata))
gsg <- goodSamplesGenes(tcount, verbose = 3)
gsg$allOK # Not sure what verbose is quite yet. All are good. If not, will be False and we would have to filter them. Refer to WGCNA manual. 

sampleTree = hclust(dist(tcount), method = "average");
# Plot the sample tree: Open a graphic output window of size 12 by 9 inches
# The user should change the dimensions if the window is too large or too small.
sizeGrWindow(12,9)
#pdf(file = "Plots/sampleClustering.pdf", width = 12, height = 9);
par(cex = 0.6);
par(mar = c(0,4,2,0))
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5,cex.axis = 1.5, cex.main = 2)
```

If there are outlier samples, we can remove them by hand or do them by an automatic approach. 
```{r, eval=FALSE, include=FALSE}
# Plot a line to show the cut
abline(h = 4.9e05, col = "red");
# Determine cluster under the line
clust = cutreeStatic(sampleTree, cutHeight = 4.9e05, minSize = 10)
table(clust)
# clust X contains the samples we want to keep.
# keepSamples = (clust==1)
# datExpr = tcount[keepSamples,]
# nGenes = ncol(datExpr)
# nSamples = nrow(datExpr)
```

Check out some of the clinical data. How do clinical variables relate to the sample dendogram?
```{r}
colnames(metadata)
str(metadata)

metaWGCNA <- metadata

metaWGCNA$Status <- ifelse(metaWGCNA$Status== "Asthma", 1, 0)
metaWGCNA$Gender <- ifelse(metaWGCNA$Gender=="Male", 1, 0)
metaWGCNA$current_smoker <- ifelse(metaWGCNA$current_smoker== "Y",1,0)
metaWGCNA$Smoke_Ever <- ifelse(metaWGCNA$Smoke_Ever== "Y",1,0)

# Still need to do this for ethnicigy 

for(i in metaWGCNA)





# Re-cluster samples
sampleTree2 = hclust(dist(datExpr), method = "average")
# Convert traits to a color representation: white means low, red means high, grey means missing entry
traitColors = numbers2colors(metadata$Age, signed = FALSE);
# Plot the sample dendrogram and the colors underneath.
plotDendroAndColors(sampleTree2, traitColors,groupLabels = names(metadata),
main = "Sample dendrogram and trait heatmap")
```


```{r}
traitData = read.csv("~/Downloads/FemaleLiver-Data/ClinicalTraits.csv");
dim(traitData)
names(traitData)
# remove columns that hold information we do not need.
allTraits = traitData[, -c(31, 16)];
allTraits = allTraits[, c(2, 11:36) ];
dim(allTraits)
names(allTraits)
# Form a data frame analogous to expression data that will hold the clinical traits.
femaleSamples = rownames(datExpr);
traitRows = match(femaleSamples, allTraits$Mice);
datTraits = allTraits[traitRows, -1];
rownames(datTraits) = allTraits[traitRows, 1];
collectGarbage();



```

